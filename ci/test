#!/bin/bash
set -e
set -u
set -o pipefail

################################################################################
# Run the test harness. Invoke as "ci/test".
################################################################################

. ci/bootstrap
. ci/functions.sh

ci/clean

echo
echo Check every file for things like trailing whitespace.
run_precommit

echo
echo Check that image exists.
docker images | grep ssllabs-scan

echo
echo Copy binary into local directory.
docker create --name scanbuild jumanjiman/ssllabs-scan true
docker cp scanbuild:/ssllabs-scan .

echo
echo Check that binary is static.
file ssllabs-scan | grep -oh 'statically linked'

echo
echo 'Check that binary is stripped (no debug symbols).'
file ssllabs-scan | grep -oh 'stripped'
file ssllabs-scan | grep -vq 'not stripped'

if [ "${CIRCLECI:-false}" == true ]; then
  echo
  echo Check that image has ci-build-url label.
  docker inspect \
    -f '{{ index .Config.Labels "io.github.jumanjiman.ci-build-url" }}' \
    jumanjiman/ssllabs-scan | \
    grep 'circleci.com'
fi

echo
echo Check that binary works.
docker-compose run --rm grade_github

echo
echo 'Another syntax to do the same thing.'
docker-compose run --rm scanner -grade -usecache https://github.com

echo
echo Start a sleeper container.
echo The process in this "FROM scratch" container is expected to run as user "user".
cid=$(docker-compose run -d sleeper)

echo
echo Check that sleeper runs as unprivileged user.
echo This proves that the technique to run a scratch container as a user still works.
echo The sleeper container does not have the "ps" command, so we
echo attach a regular container to the namespace of the sleeper container.
docker run --rm -it --pid container:"${cid}" --network container:"${cid}" alpine:3.8 ps -o pid,user,group,comm | grep -E '1 1000     1000     sleeper'
docker-compose down
